##Lab4: 死锁
***
* 死锁程序结果
* 死锁条件
* 死锁程序解释

***
### 死锁程序结果
####循环运行100次以下死锁程序
	class A {
	synchronized void methodA(B b) {
		b.last();
		}

	synchronized void last() {
		System.out.println("Inside A.last()");
		}
	}

	class B {
	synchronized void methodB(A a) {
		a.last();
		}

	synchronized void last() {
		System.out.println("Inside B.last()");
		}
	}

	class Deadlock implements Runnable{
	A a=new A();
	B b=new B();
	
	Deadlock(){
		Thread t=new Thread(this);
		int count=20000;
		t.start();
		while(count-->0);
		a.methodA(b);
	}
	public void run(){
		b.methodB(a);
	}
	public static void main(String args[]){
		new Deadlock();
	}
	}
运行结果如下图，在第62次发生死锁。

![](http://yotuku.cn/link?url=V1WUZM6eG&tk_plan=free&tk_storage=tietuku&tk_vuid=6cc2b7d8-3db3-4f7b-8e86-82b31cb96a85&tk_time=2016111015)	


###死锁条件
死锁就是两个或者多个进程，互相请求对方占有的资源。产生死锁有4个必要条件：
* 互斥条件：一个资源每次只能被一个进程使用
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

###死锁程序解释

对于A和B类中的方法使用了关键字 *synchronized* 修饰。当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。

而在Deadlock主函数中，新建了一个线程t，当 *t.start()* 之后，线程t就被插入到调度队列里，当调度到他的时候，就执行run()里面的代码。

而当死锁函数中的 *a.methodA(b)* 和run中的 *b.methodB(a)* 同时执行时，由于关键字synchronized的存在，其中一个方法将被阻塞，程序也无法运行下去，这样就会产生上图中的结果，发生死锁。

程序运行时间轴如下图所示：

![](http://yotuku.cn/link?url=NJY_4faxG&tk_plan=free&tk_storage=tietuku&tk_vuid=6cc2b7d8-3db3-4f7b-8e86-82b31cb96a85&tk_time=2016111015)




